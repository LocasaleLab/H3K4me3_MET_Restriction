#include<iostream>
#include<fstream>
#include<sstream>
#include<string>
#include<vector>
#include<algorithm>

//Generate reads coverage curves from .bdg files generated by MACS2


using namespace std;


struct Region{
	string chr;
	int p1;
	int p2;
};
typedef Region *PRegion;

struct RegionList{
	vector<Region> regions;
	vector<int> types;
};

struct PosList{
	vector<Region> regions;
	vector<double> pileups;
};

vector<string> splitString(string str, char delimiter)
//Split string to several substrings by a predefined delimiter
{
	vector<string> internal;
	stringstream ss(str);
	string tok;
	while(getline(ss,tok,delimiter))
		internal.push_back(tok);
	return internal;
}

int str2int(string str)
{
	stringstream ss(str);
	int val;
	ss>>val;
	return val;
}

double str2double(string str)
{
	stringstream ss(str);
	double val;
	ss>>val;
	return val;
}

PosList readPosInfo(string posFile)
{
	ifstream fin(posFile.c_str());
	string line;
	vector<Region> poses;
	vector<double> hs;
	if(fin.is_open())
	{
		while(getline(fin,line))
		{
			vector<string> words=splitString(line,'\t');
			string chr=words[0];
			string begin=words[1];
			string end=words[2];
			string h=words[3];
//			h=h.substr(0,h.size()-1);
			Region pos;
			pos.chr=chr;
			pos.p1=str2int(begin);
			pos.p2=str2int(end);
			double pileup=str2double(h);
			poses.push_back(pos);
			hs.push_back(pileup);
		}
		fin.close();
	}
	PosList PL;
	PL.regions=poses;
	PL.pileups=hs;
	return PL;
}


RegionList readRegionInfo(void)
{
	vector<string> annoTypes;
	string s0("Intergenic");
	string s1("promoter-TSS");
	string s2("non-coding");
	string s3("intron");
	string s4("TTS");
	string s5("exon");
	string s6("5'UTR");
	string s7("3'UTR");
	annoTypes.clear();
	annoTypes.push_back(s0);
	annoTypes.push_back(s1);
	annoTypes.push_back(s2);
	annoTypes.push_back(s3);
	annoTypes.push_back(s4);
	annoTypes.push_back(s5);
	annoTypes.push_back(s6);
	annoTypes.push_back(s7);
	ifstream fin("GenomicRegions.txt");
	string line;
	vector<Region> regions;
	vector<int> types;
	if(fin.is_open())
	{
		while(getline(fin,line))
		{
			vector<string> words=splitString(line,'\t');
			string type=words[0];
			string chr=words[1];
			string begin=words[2];
			string end=words[3];
			//end=end.substr(0,end.size()-1);
			Region reg;
			reg.chr=chr;
			stringstream ss1(begin);
			stringstream ss2(end);
			int vbegin,vend,vtype;
			vtype=find(annoTypes.begin(),annoTypes.end(),type)-annoTypes.begin();
			ss1 >> vbegin;
			ss2 >> vend;
			reg.p1=vbegin;
			reg.p2=vend;
			types.push_back(vtype);
			regions.push_back(reg);
		}
	}
	RegionList RL;
	RL.regions=regions;
	RL.types=types;
	return RL;
}
			


inline bool isOverlap(Region R1,Region R2)
{
	if(R1.chr.compare(R2.chr)==0 && max(R1.p2,R2.p2)-min(R1.p1,R2.p1)<=R1.p2-R1.p1+R2.p2-R2.p1)
		return true;
	else
	{
	//	cout<<R1.chr<<" is not "<<R2.chr<<endl;
	//	cout<<max(R1.p2,R2.p2)-min(R1.p1,R2.p1)<<endl;
	//	cout<<R1.p2-R1.p1+R2.p2-R2.p1<<endl;
	//	cout<<R1.p1<<"\t"<<R1.p2<<endl;
	//	cout<<R2.p1<<"\t"<<R2.p2<<endl;
		return false;
	}
}




int main(int argc, char *argv[])
{
	string RunID(argv[1]);
	string bdg("_sorted_pileup.bdg");
	string curve("_PeakCurves.txt");
	string bdgFile=RunID+bdg;
	string posFile="MergedPeaks.bed";
	string curveFile=RunID+curve;
	PosList PL=readPosInfo(bdgFile);
	RegionList RL=readRegionInfo();
	cout<<"Read Finished!"<<endl;
	int search_start=0;
	int search_end=PL.regions.size();
	int OldPos=0;
	ifstream fin(posFile.c_str());
	ofstream fout(curveFile.c_str());
	string line;
	int CurrentPos=0;
	if(fin.is_open())
	{
		while(getline(fin,line))
		{
			cout<<line<<endl;
			vector<string> words=splitString(line,'\t');
			string chro=words[0];
			int begin=str2int(words[1]);
			int end=str2int(words[2]);//.substr(0,words[2].size()-1));
			Region Peak;
			Peak.chr=chro;
			Peak.p1=begin;
			Peak.p2=end;
			for(int i=search_start;i<search_end;i++)
			{
				Region pos=PL.regions[i];
				double h=PL.pileups[i];
				bool foundTag=false;
				if(isOverlap(Peak,pos)==true)
				{
					foundTag=true;
					int len=min(pos.p2,Peak.p2)-max(pos.p1,Peak.p1);
					for(int j=0;j<len;j++)
						fout<<h<<"\t";
				}
				else if(foundTag==true)
				{
					search_start=i-1;
					break;
				}
			}
			fout<<endl;
		}
	}
	else
		cout<<"Failed opening peakpos file..."<<endl;
	fin.close();
	fout.close();

	return 0;
}
